#![warn(missing_docs)]

use std::{
    any::Any,
    ops::ControlFlow,
    sync::mpsc::{Receiver, Sender, channel},
    thread::{self},
    time::Duration,
};

pub use crate::event::{EventHook, Events};
use crate::{context::Context, event::EventHookMut};
use crossterm::event::{self};
use ratatui::{DefaultTerminal, Frame};
/// Trait that will be implemented by [ratatui_router_derive::Routes] derive macro
///
/// Defines navigatable routes
/// Main entry to create [Router]
pub trait Routed
where
    Self: Sized,
{
    /// The type that will be used to determine which events will be available to get via [EventHook::get_event](crate::event::EventHook::get_event)
    ///
    /// This type is automatically generated by the macro and named as `<EnumName>` + `Event`
    ///
    /// # Example
    /// ```ignore
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// pub enum CustomEventEnum {
    ///     // ...all your events
    /// }
    /// #[derive(Routes)] // <-- derive macro
    /// pub enum MyRoutes {
    ///     #[event(CustomEventEnum)] // <-- value that will be used as possible custom events inside TestPage
    ///     TestPage,
    ///     #[event(i64)] // <-- value that will be used as events inside TEST page
    ///     TEST(),
    ///     Test1 { a: String, b: usize },
    /// }
    /// // pub enum MyRoutesEvent { // <-- Enum generated by derive macro
    /// //     TestPage(CustomEventEnum),
    /// //     TEST(i64),
    /// // }
    /// ```
    type Ev: Send + 'static;

    /// Implemented by [ratatui_router_derive::Routes] derive macro
    ///
    /// You should only implement a function with the same name, and params.
    ///
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// ```
    fn render(&mut self, ctx: &mut Router<Self>, frame: &mut Frame) -> ();

    /// Implemented by [ratatui_router_derive::Routes] derive macro
    ///
    /// Convenient method to create Router, with the provided default page, which opens at startup;
    /// For more see [Router]
    ///
    /// ```no_run
    /// use color_eyre::Result;
    /// use crossterm::event::{self, Event};
    /// use ratatui::{DefaultTerminal, Frame};
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     assert_eq!(*a, "Hello".to_string());
    ///     assert_eq!(*b, 0);
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() -> Result<()> {
    ///    color_eyre::install()?;
    ///    let terminal = ratatui::init();
    ///    MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0}).run(terminal);
    ///    Ok(())
    /// }
    /// ```
    fn create_router(default: Self) -> Router<Self> {
        Router::new(default)
    }
}
/// Handles the render loop and event processing
pub struct Router<T: Routed> {
    history: Vec<T>,
    history_length: usize,
    current: Option<T>,
    looping: bool,
    tx: Sender<Events<T::Ev>>,
    rx: Receiver<Events<T::Ev>>,
    ping: (Sender<ControlFlow<()>>, Receiver<ControlFlow<()>>),
    // use option so we can take value and pass it to use_xxx hooks
    // the value should never be None
    event: Option<Events<T::Ev>>,
    context: Context,
}

impl<T: Routed> Router<T> {
    /// Creates new Router with default page, prefered to use [Routed::create_router]
    pub fn new(default: T) -> Self {
        let (tx, rx) = channel();
        Self {
            history: Vec::new(),
            history_length: 1,
            current: Some(default),
            looping: true,
            tx,
            rx,
            ping: channel(),
            event: Option::Some(Events::Started),
            context: Context::new(),
        }
    }
    /// Creates context for passed value that you can get later with [Router::get_context]
    ///
    /// If context was already created it will be replaced with new value
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    router.create_context::<i64>(0);
    ///    assert_eq!(*router.get_context::<i64>().borrow(), 0);
    ///    router.create_context::<i64>(2);
    ///    assert_eq!(*router.get_context::<i64>().borrow(), 2);
    /// }
    /// ```
    pub fn create_context<V: Any>(&mut self, t: V) {
        self.context.create_context(t);
    }

    /// Returns a shared reference to the context value
    ///
    /// Panics if the context has not been created
    ///
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    ///     Test2 ()
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     ctx.change_page(MyRoutes::Test2());
    ///     ctx.create_context::<i8>(2);
    /// }
    ///
    /// pub fn Test2(ctx: &mut Router<MyRoutes>, frame: &mut Frame) -> (){
    ///     assert_eq!(*ctx.get_context::<i64>().borrow(), 1);
    ///     assert_eq!(*ctx.get_context::<i8>().borrow(), 2);
    ///     // render stuff
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    router.create_context::<i64>(1);
    ///    // router.run();
    /// }
    /// ```
    pub fn get_context<V: Any>(&self) -> std::rc::Rc<std::cell::RefCell<V>> {
        self.context.get_context()
    }

    /// Checks if context exists
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     assert_eq!(ctx.is_context_exists::<i64>(), true);
    /// }
    ///
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    assert_eq!(router.is_context_exists::<i64>(), false);
    ///    router.create_context::<i64>(1);
    ///    assert_eq!(router.is_context_exists::<i64>(), true);
    ///    // router.run();
    /// }
    /// ```
    pub fn is_context_exists<V: Any>(&self) -> bool {
        self.context.is_context_exists::<V>()
    }

    /// Sends some event, that you can later read with [crate::event::EventHook::get_event]
    pub fn send_event(&mut self, event: T::Ev) {
        self.tx.send(Events::Custom(event)).expect("Failed to send");
    }

    /// Returns cloned Sender so you can move it for example, to another Thread, then process some data, and return computed value
    ///
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// use std::thread;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///    #[event(i64)] // <-- allow event to be used
    ///    Test1 { started_computing: bool, computed_data: Option<i64> },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, started_computing: &mut bool, computed_data: &mut Option<i64>) -> () {
    ///     let tx = ctx.tx();
    ///     if !*started_computing {    
    ///         thread::spawn(move || {
    ///             let i: i64 = 0;
    ///             // very heavy task
    ///             tx.send(MyRoutesEvent::Test1(i).into()).unwrap();
    ///             // Into trait implemented by derive, but you can also use this
    ///             // tx.send(router::Events::Custom(MyRoutesEvent::Test1(i))).unwrap();
    ///         });
    ///         *started_computing = true;
    ///     }
    ///     match ctx.get_event() {
    ///         Events::Custom(MyRoutesEvent::Test1(i)) => *computed_data = Some(*i),
    ///         _ => {}
    ///     }
    /// }
    pub fn tx(&self) -> Sender<Events<T::Ev>> {
        self.tx.clone()
    }

    /// Shorthand for sending [Events::Exit] event;
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// use std::thread;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///    Test1(),
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame) -> () {
    ///     match ctx.get_event() {
    ///         Events::Event(event) => match event {
    ///             crossterm::event::Event::Key(key_event) => {
    ///                 if key_event.code.is_esc() {
    ///                     // esc button was pressed, now we need to exit the app
    ///                     ctx.exit();
    ///                 }
    ///            },
    ///            _ => {}
    ///         },
    ///         Events::Exit => {
    ///             // for example save some data
    ///         },
    ///         _ => {}
    ///     }
    /// }
    /// ```
    pub fn exit(&mut self) {
        self.tx.send(Events::Exit).expect("Failed to send");
    }

    fn render(&mut self, frame: &mut Frame) {
        let mut current = self.current.take().unwrap();
        current.render(self, frame);
        if self.current.is_none() {
            self.current = Some(current);
        } else {
            self.history.push(current);
        }
    }

    /// Clears page history, that otherwise would be used in [Router::go_back]
    ///
    /// By default, history can store up to 1 element, if you wish to change that value call [Router::history_limit]
    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    /// Changes, how much elements history can store, by default, up to 1 element
    pub fn history_limit(&mut self, max: usize) {
        self.history_length = max;
    }

    /// Returns to previous page, if history isn't empty and we have page that we can return to returns true, and sends [Events::PageChanged], otherwise returns false
    pub fn go_back(&mut self) -> bool {
        if self.history.len() > 0 {
            let item = self.history.remove(self.history.len() - 1);
            self.current = Some(item);
            self.tx.send(Events::PageChanged).expect("Failed to send");
            true
        } else {
            false
        }
    }

    /// Changes current page and sends [Events::PageChanged] event
    pub fn change_page(&mut self, path: T) {
        if self.current.is_some() {
            self.history.push(self.current.take().unwrap());
        }
        self.current = Some(path);
        self.tx.send(Events::PageChanged).unwrap();
    }

    /// Blocks the current thread and starts main loop of program
    ///
    /// # Example
    /// ```no_run
    /// use color_eyre::Result;
    /// use crossterm::event::{self, Event};
    /// use ratatui::{DefaultTerminal, Frame};
    /// use ratatui_router::{router::*, event::*};
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() -> Result<()> {
    ///    color_eyre::install()?;
    ///    let terminal = ratatui::init();
    ///    MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0}).run(terminal);
    ///    Ok(())
    /// }
    /// ```
    pub fn run(mut self, mut terminal: DefaultTerminal) -> std::io::Result<()> {
        let tx = self.tx.clone();
        let ping = self.ping.0.clone();
        thread::spawn(move || {
            loop {
                if event::poll(Duration::from_secs(1)).expect("Failed to poll") {
                    tx.send(Events::Event(event::read().unwrap())).unwrap();
                } else {
                    // check that the program have ended so we can close thread;
                    if ping.send(ControlFlow::Continue(())).is_err() {
                        break;
                    };
                }
            }
        });
        terminal.draw(|frame| self.render(frame))?;
        while self.looping {
            let event = self.rx.recv().expect("Failed to receive");
            self.event = Option::Some(event);
            terminal.draw(|frame| self.render(frame))?;
            match self.event.unwrap() {
                Events::Exit => {
                    self.looping = false;
                    break;
                }
                _ => {}
            }
        }
        drop(self.ping);
        ratatui::restore();
        Ok(())
    }
}

impl<T: Routed> EventHook<T::Ev> for Router<T> {
    fn get_event(&self) -> &Events<T::Ev> {
        if let Some(ev) = &self.event {
            return ev;
        }
        panic!("Value shouldn't be empty");
    }
}

impl<T: Routed> EventHookMut<T::Ev> for Router<T> {
    fn get_event_mut(&mut self) -> &mut Option<Events<T::Ev>> {
        &mut self.event
    }
    
    fn set_event(&mut self, event: Events<T::Ev>) {
        self.event = Some(event);
    }
}

#![warn(missing_docs)]

use std::{
    any::Any,
    ops::ControlFlow,
    sync::mpsc::{Receiver, Sender, channel},
    thread::{self},
    time::Duration,
};

use crossterm::event::{self, Event};
use ratatui::{DefaultTerminal, Frame};

use crate::context::Context;
/// Trait that will be implemented by [ratatui_router_derive::Routes] derive macro
///
/// Defines navigatable routes
/// Main entry to create [Router]
pub trait Routed
where
    Self: Sized,
{
    /// The type that will be used to determine which events will be available to get via [Router::event]
    ///
    /// This type is automatically generated by the macro and named as `<EnumName>` + `Event`
    ///
    /// # Example
    /// ```ignore
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// pub enum CustomEventEnum {
    ///     // ...all your events
    /// }
    /// #[derive(Routes)] // <-- derive macro
    /// pub enum MyRoutes {
    ///     #[event(CustomEventEnum)] // <-- value that will be used as possible custom events inside TestPage
    ///     TestPage,
    ///     #[event(i64)] // <-- value that will be used as events inside TEST page
    ///     TEST(),
    ///     Test1 { a: String, b: usize },
    /// }
    /// // pub enum MyRoutesEvent { // <-- Enum generated by derive macro
    /// //     TestPage(CustomEventEnum),
    /// //     TEST(i64),
    /// // }
    /// ```
    type Ev: Send + 'static;

    /// Implemented by [ratatui_router_derive::Routes] derive macro
    ///
    /// You should only implement a function with the same name, and params. 
    ///
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// ```
    fn render(&mut self, ctx: &mut Router<Self>, frame: &mut Frame) -> ();

    /// Implemented by [ratatui_router_derive::Routes] derive macro
    ///
    /// Convenient method to create Router, with the provided default page, which opens at startup;
    /// For more see [Router]
    ///
    /// ```no_run
    /// use color_eyre::Result;
    /// use crossterm::event::{self, Event};
    /// use ratatui::{DefaultTerminal, Frame};
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     assert_eq!(*a, "Hello".to_string());
    ///     assert_eq!(*b, 0);
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() -> Result<()> {
    ///    color_eyre::install()?;
    ///    let terminal = ratatui::init();
    ///    MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0}).run(terminal);
    ///    Ok(())
    /// }
    /// ```
    fn create_router(default: Self) -> Router<Self> {
        Router::new(default)
    }
}
/// Handles the render loop and event processing
pub struct Router<T: Routed> {
    history: Vec<T>,
    history_length: usize,
    current: Option<T>,
    looping: bool,
    tx: Sender<Events<T::Ev>>,
    rx: Receiver<Events<T::Ev>>,
    ping: (Sender<ControlFlow<()>>, Receiver<ControlFlow<()>>),
    event: Option<Events<T::Ev>>,
    context: Context,
}

/// Enum value that will be used as events, where `T` = [Routed::Ev]
pub enum Events<T> {
    /// Events that will be created from fields marked with `#[event()]`, for details, see [Routed::Ev]
    Custom(T),
    /// Crossterm event, for example key that was pressed.
    Event(Event),
    /// Event that means last render of program and exiting render loop
    Exit,
    /// Called when page was changed via [Router::change_page] or [Router::go_back]
    PageChanged
}

impl<T: Routed> Router<T> {
    /// Creates new Router with default page, prefered to use [Routed::create_router]
    pub fn new(default: T) -> Self {
        let (tx, rx) = channel();
        Self {
            history: Vec::new(),
            history_length: 1,
            current: Some(default),
            looping: true,
            tx,
            rx,
            ping: channel(),
            event: None,
            context: Context::new(),
        }
    }
    /// Creates context for passed value that you can get later with [Router::get_context]
    ///
    /// If context was already created it will be replaced with new value
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    router.create_context::<i64>(0);
    ///    assert_eq!(*router.get_context::<i64>().borrow(), 0);
    ///    router.create_context::<i64>(2);
    ///    assert_eq!(*router.get_context::<i64>().borrow(), 2);
    /// }
    /// ```
    pub fn create_context<V: Any>(&mut self, t: V) {
        self.context.create_context(t);
    }

    /// Returns a shared reference to the context value
    ///
    /// Panics if the context has not been created
    ///
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    ///     Test2 ()
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     ctx.change_page(MyRoutes::Test2());
    ///     ctx.create_context::<i8>(2);
    /// }
    ///
    /// pub fn Test2(ctx: &mut Router<MyRoutes>, frame: &mut Frame) -> (){
    ///     assert_eq!(*ctx.get_context::<i64>().borrow(), 1);
    ///     assert_eq!(*ctx.get_context::<i8>().borrow(), 2);
    ///     // render stuff
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    router.create_context::<i64>(1);
    ///    // router.run();
    /// }
    /// ```
    pub fn get_context<V: Any>(&self) -> std::rc::Rc<std::cell::RefCell<V>> {
        self.context.get_context()
    }

    /// Checks if context exists
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     assert_eq!(ctx.is_context_exists::<i64>(), true);
    /// }
    ///
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0});
    ///    assert_eq!(router.is_context_exists::<i64>(), false);
    ///    router.create_context::<i64>(1);
    ///    assert_eq!(router.is_context_exists::<i64>(), true);
    ///    // router.run();
    /// }
    /// ```
    pub fn is_context_exists<V: Any>(&self) -> bool {
        self.context.is_context_exists::<V>()
    }

    /// Sends some event, that you can later read with [Router::event]
    pub fn send_event(&mut self, event: T::Ev) {
        self.tx.send(Events::Custom(event)).expect("Failed to send");
    }

    /// Returns cloned Sender so you can move it for example, to another Thread, then process some data, and return computed value
    ///
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// use std::thread;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///    #[event(i64)] // <-- allow event to be used
    ///    Test1 { started_computing: bool, computed_data: Option<i64> },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, started_computing: &mut bool, computed_data: &mut Option<i64>) -> () {
    ///     let tx = ctx.tx();
    ///     if !*started_computing {    
    ///         thread::spawn(move || {
    ///             let i: i64 = 0;
    ///             // very heavy task
    ///             tx.send(MyRoutesEvent::Test1(i).into()).unwrap();
    ///             // Into trait implemented by derive, but you can also use this
    ///             // tx.send(router::Events::Custom(MyRoutesEvent::Test1(i))).unwrap();
    ///         });
    ///         *started_computing = true;
    ///     }
    ///     if let Some(event) = ctx.event() {
    ///         match event {
    ///             Events::Custom(MyRoutesEvent::Test1(i)) => *computed_data = Some(*i),
    ///             _ => {}
    ///         }
    ///     }
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1{started_computing: false, computed_data: None});
    ///    // router.run();
    /// }
    /// ```
    pub fn tx(&self) -> Sender<Events<T::Ev>> {
        self.tx.clone()
    }

    /// Get reference to current event, that have caused redraw
    ///
    /// For [Events::Custom] details, see [Routed::Ev]
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// use std::thread;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///    Test1(),
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame) -> () {
    ///     if let Some(event) = ctx.event() {
    ///         match &event {
    ///             Events::Custom(_) => todo!(),
    ///             Events::Event(event) => match event {
    ///                 crossterm::event::Event::Key(key_event) => {
    ///                     if  key_event.code.is_esc() {
    ///                         ctx.exit();
    ///                     }
    ///                },
    ///                 _ => {}
    ///             },
    ///             Events::Exit => {},
    ///             Events::PageChanged => {},
    ///         }
    ///      }
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1());
    ///    // router.run();
    /// }
    /// ```
    pub fn event(&self) -> &Option<Events<T::Ev>> {
        &self.event
    }

    /// Shorthand for sending [Events::Exit] event;
    /// # Example
    /// ```
    /// use ratatui::Frame;
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// use std::thread;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///    Test1(),
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame) -> () {
    ///     ctx.exit();
    ///     /// At first run, event will be None, but immediately redraw called and event value = Event::Exit
    ///     if let Some(event) = ctx.event() {
    ///         match &event {
    ///             Events::Custom(_) => todo!(),
    ///             Events::Event(event) => match event {
    ///                 crossterm::event::Event::Key(key_event) => {
    ///                     if  key_event.code.is_esc() {
    ///                         ctx.exit();
    ///                     }
    ///                },
    ///                 _ => {}
    ///             },
    ///             Events::Exit => {},
    ///             Events::PageChanged => {},
    ///         }
    ///     }
    /// }
    /// pub fn main() {
    ///    let mut router = MyRoutes::create_router(MyRoutes::Test1());
    ///    // router.run();
    /// }
    /// ```
    pub fn exit(&mut self) {
        self.tx.send(Events::Exit).expect("Failed to send");
    }

    fn render(&mut self, frame: &mut Frame) {
        let mut current = self.current.take().unwrap();
        current.render(self, frame);
        if self.current.is_none() {
            self.current = Some(current);
        } else {
            self.history.push(current);
        }
    }

    /// Clears page history, that otherwise would be used in [Router::go_back]
    /// 
    /// By default, history can store up to 1 element, if you wish to change that value call [Router::history_limit]
    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    /// Changes, how much elements history can store, by default, up to 1 element 
    pub fn history_limit(&mut self, max: usize)  {
        self.history_length = max;
    }

    /// Returns to previous page, if history isn't empty and we have page that we can return to returns true, and sends [Events::PageChanged], otherwise returns false
    pub fn go_back(&mut self) -> bool {
        if self.history.len() > 0 {
            let item = self.history.remove(self.history.len() - 1);
            self.current = Some(item);
            self.tx.send(Events::PageChanged).expect("Failed to send");
            true
        } else {
            false
        }
    }

    /// Changes current page and sends [Events::PageChanged] event
    pub fn change_page(&mut self, path: T) {
        if self.current.is_some() {
            self.history.push(self.current.take().unwrap());
        }
        self.current = Some(path);
        self.tx.send(Events::PageChanged).unwrap();
    }

    /// Blocks the current thread and starts main loop of program
    /// 
    /// # Example
    /// ```no_run
    /// use color_eyre::Result;
    /// use crossterm::event::{self, Event};
    /// use ratatui::{DefaultTerminal, Frame};
    /// use ratatui_router::router::*;
    /// use ratatui_router_derive::Routes;
    /// #[derive(Routes)]
    /// pub enum MyRoutes {
    ///     Test1 { a: String, b: usize },
    /// }
    /// pub fn Test1(ctx: &mut Router<MyRoutes>, frame: &mut Frame, a: &mut String, b: &mut usize) -> () {
    ///     // do render and event handling stuff here
    /// }
    /// pub fn main() -> Result<()> {
    ///    color_eyre::install()?;
    ///    let terminal = ratatui::init();
    ///    MyRoutes::create_router(MyRoutes::Test1{a: "Hello!".to_string(), b: 0}).run(terminal);
    ///    Ok(())
    /// }
    /// ```
    pub fn run(mut self, mut terminal: DefaultTerminal) -> std::io::Result<()> {
        let tx = self.tx.clone();
        let ping = self.ping.0.clone();
        let thread = thread::spawn(move || {
            loop {
                if event::poll(Duration::from_secs(1)).expect("Failed to poll") {
                    tx.send(Events::Event(event::read().unwrap())).unwrap();
                } else {
                    // check that the program have ended so we can close thread;
                    if ping.send(ControlFlow::Continue(())).is_err() {
                        break;
                    };
                }
            }
        });
        terminal.draw(|frame| self.render(frame))?;
        while self.looping {
            let event = self.rx.recv().expect("Failed to receive");
            self.event = Some(event);
            terminal.draw(|frame| self.render(frame))?;
            let event = self.event.take().unwrap();
            match event {
                Events::Exit => {
                    self.looping = false;
                    break;
                }
                _ => {}
            }
        }
        drop(self.ping);
        ratatui::restore();
        Ok(())
    }
}
